DESIGN PRINCIPLES
-----------------
* Accessibility. The library should be easy to set up and use. It should be easy and painless to quickly throw together a UI to control some parameters of a sketch. This is in spirit of the 'sketching metaphor' of processing.
* Minimalism. Graphic elements should be clean in design, easily readable and understandable. A basic but usable set of user interface elements should be provided.
* Extensibility. Allow for customizing the display of UI Elements and support creating completely new ones regardless of the type of data they represent.


IDEAS
-----
* Separate Event System Library (see ofxEvent)
* Basic Elements (Slider, Button, Toggle, Label, Divider)
* Sensible Defaults (Position, Size, Proportion)
* Grid Based Layout
* Graphical Layout Adjustment ("Edit Mode", Drag & Drop)
* Minimal Theme
* Auto connect to variables and functions (by name)
* Write your own elements (Functionality & Look)
* Accessible Documentation (see Interfascia)
* Documentation through examples
* GUI Overlay
* Save and load parameters
* Method Chaining (controlP5)
* Feedback when an Element auto-connects (console)
* Main GUI Object has a graphic representation (the overlay). When empty contains a notice that elements need to be added.
* Automatic Labels for elements
* Simplest way to create a GUI Element?
* Performance: Draw GUI in offscreen buffer. Only redraw when changed.
* Possible to avoid class syntax? (beginners!)


REFERENCES
----------
processing library basics https://github.com/processing/processing/wiki/Library-Basics
processing library guidelines https://github.com/processing/processing/wiki/Library-Guidelines
ofxUI https://github.com/rezaali/ofxUI
ofEvent http://www.openframeworks.cc/documentation/events/ofEvent.html
java reflection http://docs.oracle.com/javase/tutorial/reflect/
controlP5 http://code.google.com/p/controlp5/
GUIDO https://github.com/fjenett/Guido
tweaker http://bezier.de/processing/tweaker/
poco events: http://pocoproject.org/docs/package-Foundation.Events-index.html


TODO
----
Master
x Base Setup
	x Repository
	x Library Template
	x Build File
x Core System
	x Event System
	x Active Regions
	x Dummy UI Element (Bang)
* Core System / API Review
	* Events (Mouse, Keyboard)
	* Class Hierarchy
	* Element Construction Pattern
* Basic UI Components
	* Button
	* Toggle
	* Slider
	* Divider
	* Label
* API Refinement
* Advanced Features
	* Theme
	* Automatic Layout
	* Saving State
	* Layout Adjustment
* More UI Elements

System
* Logger instead of System.out
* Faster build (reuse preprocessed files/tmp)
* Proper dist and tagging

Event System
x List of Events
x Review Event Systems 
	x Processing
 	x OpenFrameworks
	x ofxUI
* Mouse Events
	* Support for different mouse buttons
* Keyboard Events

Class Hierarchy / API
* Main Class (PUI)
	* Singleton vs. multiple instances
* Element Base Class / Widget
* Elements/Widgets
	* Handle Events from PUI
	* Data/State/Model
	* Presentation/Rendering/View
	* User Drawing
	* User Event handling
* Event/Callback Pattern
* User controlled drawing
* User Events
* Widget creation (without classes)


EVENTS
------
Processing MouseEvent:
ENTER
EXIT
MOVE
PRESS - DRAG - RELEASE
PRESS - RELEASE - CLICK
WHEEL 
Parameters:
getX()
getY()
getButton() 
getCount()

Processing KeyEvent:
PRESS
RELEASE
TYPE
Parameters
getKey()
getKeyCode()

Processing Events without Arguments:
pre
draw
post
pause
resume
dispose

Element:
mouseEntered(x, y)
mouseMoved(x, y)
mouseExited(x, y)
mousePressed(x, y, button)
mouseReleased(x, y, button)
mouseClicked(x, y, button)
mouseDoubleClicked(x, y, button)
mouseDragged(x, y, button)
mouseScrolled(x, y, amount)

Element States:
active
hover
pressed
dragged


OpenFrameworks Events
---------------------
class ofEvent<ArgumentsType> : define an event (type)
ofAddListener(event, object, method) : register any method of any class to an event
ofRemoveListener(event, object, method)
ofNotifyEvent(event, arguments)

class ofEventArgs ()
class ofKeyEventArgs (type, key)
class ofMouseEventArgs (type, button, x, y)
class ofMessage (message)

class ofCoreEvents:
	ofEvent<ofEventArgs> setup, update, draw, exit
	ofEvent<ofKeyEventArgs> keyPressed, keyReleased
	ofEvent<ofMouseEventArgs> mouseMoved, mouseDragged, mousePressed, mouseReleased
	ofEvent<ofMessage> messageEvent
ofEvents() : returns a static instance of ofCoreEvents


ofxUI Classes & Events
----------------------
ofUICBGlue : connects to OF events

ofUIWidget : rendering, properties: name, kind, id, parent, visible, hit

ofUIEventArgs : holds a reference to a ofxUIWidget

ofUICanvas : extends ofUIWidget, ofUICBGlue. 
	ofEvent<ofxUIEventArgs> newGUIEvent : event registry

mechanism:
	gui = new ofxUICanvas()
	gui.addSlider("name")
	gui.addWidget(new ofUIWidget())
	ofAddListener(gui->newGUIEvent, this, guiEvent)
	central callback function: guiEvent(ofxUIEventArgs args)


Sample Elements
---------------
Button
	label
	state: down, up
	events: pressed, released, clicked(count)

Toggle
	label
	state: on, off
	events: toggled, toggledOn, toggledOff

Slider
	label
	min, max
	state: value
	events: slideStart, sliding(value), valueChanged(value)


Basic Element Requirements
--------------------------
1. Receive Events from PUI
2. Encapsulate State / Model
3. Encapsulate Rendering / View
4. Allow User Event Handling
5. Allow User Rendering

1. Receive Events from PUI
* Bundled Events (keyEvent, mouseEvent, drawEvent) or split up (mousePressed, mouseReleased, ...)
	* Bundled: less repeated code:  test for active / boundaries
* Test Responsibility (mouse position inside element), active, etc. In PUI or Widget?
* Do Keyboard Events make sense for elements? Need to combine with some kind of focus feature?
* Where are MouseButton Constants?
* Don't use UIEvents interface. this way the event methods can be protected and are only accessible in subclasses.
	Or use an package private abstract BaseWidget and extend it with empty implementations of handler methods

2. Encapsulate State / Model
Subclass Widget and add instance vars
* basic state (active, pressed, hover) with getters so vars can't be overridden in subclasses

3. Encapsulate Rendering / View
Subclass Widget and override draw().

4. Allow User Event Handling

5. Allow User Rendering
Specify a draw callback, where the complete element state is passed. or the element itself.